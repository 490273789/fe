# 5-1. 新增的对象字面量语法

1. 成员速写

如果对象字面量初始化时，成员的名称来自于一个变量，并且和变量的名称相同，则可以进行简写

2. 方法速写

对象字面初始化时，方法可以省略冒号和 function 关键字

3. 计算属性名

有的时候，初始化对象时，某些属性名可能来自于某个表达式的值，在 ES6，可以使用中括号来表示该属性名是通过计算得到的。

# 5-2. Object 的新增 API

1. Object.is

用于判断两个数据是否相等，基本上跟严格相等（===）是一致的，除了以下两点：

1. NaN 和 NaN 相等
2. +0 和-0 不相等

2) Object.assign

用于混合对象

3. Object.getOwnPropertyNames 的枚举顺序

Object.getOwnPropertyNames 方法之前就存在，只不过，官方没有明确要求，对属性的顺序如何排序，如何排序，完全由浏览器厂商决定。

ES6 规定了该方法返回的数组的排序方式如下：

- 先排数字，并按照升序排序
- 再排其他，按照书写顺序排序

4. Object.setPrototypeOf

该函数用于设置某个对象的隐式原型

比如： Object.setPrototypeOf(obj1, obj2)，
相当于： `obj1.__proto__ = obj2`

# 面向对象简介

面向对象：一种编程思想，跟具体的语言

对比面向过程：

- 面向过程：思考的切入点是功能的步骤
- 面向对象：思考的切入点是对象的划分

【大象装冰箱】

# 类：构造函数的语法糖

## 传统的构造函数的问题

1. 属性和原型方法定义分离，降低了可读性
2. 原型成员可以被枚举
3. 默认情况下，构造函数仍然可以被当作普通函数使用

## 类的特点

1. 类声明不会被提升，与 let 和 const 一样，存在暂时性死区
2. 类中的所有代码均在严格模式下执行
3. 类的所有方法都是不可枚举的
4. 类的所有方法都无法被当作构造函数使用
5. 类的构造器必须使用 new 来调用

# 5-5. 类的其他书写方式

1. 可计算的成员名

2. getter 和 setter

Object.defineProperty 可定义某个对象成员属性的读取和设置

使用 getter 和 setter 控制的属性，不在原型上

3. 静态成员

构造函数本身的成员

使用 static 关键字定义的成员即静态成员

4. 字段初始化器（ES7）

注意：

1). 使用 static 的字段初始化器，添加的是静态成员
2). 没有使用 static 的字段初始化器，添加的成员位于对象上
3). 箭头函数在字段初始化器位置上，指向当前对象

5. 类表达式

6. [扩展]装饰器（ES7）(Decorator)

横切关注点

装饰器的本质是一个函数

# 5-6. 类的继承

如果两个类 A 和 B，如果可以描述为：B 是 A，则，A 和 B 形成继承关系

如果 B 是 A，则：

1. B 继承自 A
2. A 派生 B
3. B 是 A 的子类
4. A 是 B 的父类

如果 A 是 B 的父类，则 B 会自动拥有 A 中的所有实例成员。

新的关键字：

- extends：继承，用于类的定义
- super
  - 直接当作函数调用，表示父类构造函数
  - 如果当作对象使用，则表示父类的原型

注意：ES6 要求，如果定义了 constructor，并且该类是子类，则必须在 constructor 的第一行手动调用父类的构造函数

如果子类不写 constructor，则会有默认的构造器，该构造器需要的参数和父类一致，并且自动调用父类构造器

【冷知识】

- 用 JS 制作抽象类
  - 抽象类：一般是父类，不能通过该类创建对象
- 正常情况下，this 的指向，this 始终指向具体的类的对象
