// 链表：和数组类似是一个有序的线性结构，有仅有一个前驱，有且只有一个后继。
// 链表中的数据单位叫“结点”，结点在内存中的分布式离散的
// 链表中每个结点的结构都包含了两部分内容：1、数据域  2、指针域
// 在js中链表可以使用对象来实现

const lint = {
  // 数据域
  value: 1,
  // 指针域，指向下一个结点的引用
  next: {
    value: 2,
    next: undefined,
  },
}

// 为了保障可以访问到起点，我们可以定义一个head指针指向链表的开始位置

// 链表结点创建
function ListNode(val) {
  this.val = val
  this.next = null
}

const node = new ListNode(1)

// 链表元素的添加
// 在尾部添加结点：只需将尾部结点的next指向新的结点就可
node.next = new ListNode(2)

console.log(node)
// 在两个元素之间插入一个新的结点： 将前结点的next指向新的结点，再将新的结点的next指向后一结点
node3 = new ListNode(3)

node3.next = node.next
node.next = node3
console.log(node)

// 链表元素的删除
// 删除的标准：在链表遍历的过程中，无法在遍历到某个结点的存在
// 在删除链表的某一个结点的时候，重点不是定位目标结点，而是定位目标结点的前驱结点
const target = node.next
node.next = target.next

console.log(node)

// 链表和数组的使用
// 在添加或删除数据结构的时候，链表的新能更加高效，只需要改变目标节点及前驱/后继节点的指针，复杂度为O(1)
// 数组在改变一个元素（非尾部元素），后面的元素的位置都需要向后移动假设十足的长度是n，增加或者删除需要移动的元素量，就会随着数组的长度n的增大而增大，成一个线性关系，复杂度是O(n)

// 在查找元素的时候数组更加的高效，可以直接通过为止进行查找，复杂度为O(1)
// 链表只能从头部元素一个一个的向后面查找,复杂度为O(n)
// js中的数组: 如果是相同类型的元素，那么对应的确实是连续内存
const arr2 = [1, 2, 3, 4]
// 如果定义了不同类型的元素，它对应的就是一段非连续内存，此时js数组不在具有数组的特征，其底层使用哈希映射分配内存空间，是由对象链表来实现的
// 什么是真正的数组定义： 存储在连续内存空间里
const arr3 = ['qwe', 1, 2, 3]
